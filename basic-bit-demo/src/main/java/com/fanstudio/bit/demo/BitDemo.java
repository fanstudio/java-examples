package com.fanstudio.bit.demo;

public class BitDemo {

    public static void main(String[] args) {
        // java中的位运算陷阱
        // 1.转换问题,2.位移符号问题,

        // ------------------1.转换问题-----------------------
        // 1111 0000 = -(2^4 + 2^5 + 2^6) = -112,
        // 当成补码减一:1110 1111,还原成原码:1001 0000 即-16
        byte a = (byte) 0xf0;

        int b = 0xf0;
        int c = a;
        byte d = -16;
        System.out.println(a);  // -16
        System.out.println(b);  // 240
        System.out.println(c);  // -16
        System.out.println(d);  // -16

        System.out.println("------------------------------------------------------");

        // ----------------------2.位移问题--------------------------------

        // 2.1 负数的位移
        // -16原码:   1000 0000 0000 0000 0000 0000 0001 0000
        // 反码:      1111 1111 1111 1111 1111 1111 1110 1111
        // 补码:      1111 1111 1111 1111 1111 1111 1111 0000
        // 右移4位:        1111 1111 1111 1111 1111 1111 1111 (0000)
        // 补齐高位: (1111)1111 1111 1111 1111 1111 1111 1111
        // 注意这里补上的是1111,而不是1000,可参阅https://zhuanlan.zhihu.com/p/30108890
        // 减一:      1111 1111 1111 1111 1111 1111 1111 1110
        // 取反:      1000 0000 0000 0000 0000 0000 0000 0001 即:-1
        System.out.println("-16 >> 4 :" + (-16 >> 4));

        // 2.2 小数据类型转换,位移计算
        // 这里的a转不转成int计算的结果都是-1,如下按照不转换的推导过程
        // -16原码:       1001 0000
        // 反码:          1110 1111
        // 补码:          1111 0000
        // 右移4位补齐高位:(1111) 1111
        // 减一:          1111 1110
        // 取反:          1000 0001 即:-1
        System.out.println("a >> 4 :" + (a >> 4));

        // 2.3 无符号右移
        // -16原码:   1000 0000 0000 0000 0000 0000 0001 0000
        // 反码:      1111 1111 1111 1111 1111 1111 1110 1111
        // 补码:      1111 1111 1111 1111 1111 1111 1111 0000
        // 右移4位:        1111 1111 1111 1111 1111 1111 1111 (0000)
        // 补齐高位: (0000)1111 1111 1111 1111 1111 1111 1111 即:268435455
        System.out.println("-16 >>> 4 :" + (-16 >>> 4));

        // 2.4 数据类型转换后的无符号右移
        // 这里的结果输出是:268435455,而不是如下推导的15,
        // 注意:这里感觉是把a转换成了int类型后执行>>>计算
        // -16原码:       1001 0000
        // 反码:          1110 1111
        // 补码:          1111 0000
        // 右移4位补齐高位:(0000) 1111 即:15
        System.out.println("a >>> 4 :" + (a >>> 4));

        // 2.5 同一值,转成不同类型后的右移差别很大

        // 2.5.1 a转成int
        //补码:      1111 1111 1111 1111 1111 1111 1111 0000
        //        & 0000 0000 0000 0000 0000 0000 1111 1111
        // 这里是先计算结果再转换成更大的存储类型,所以结果为:240
        System.out.println("a & 0xff :" + (a & 0xff));

        // 2.5.2 转成int后位移
        //补码:      1111 1111 1111 1111 1111 1111 1111 0000
        //        & 0000 0000 0000 0000 0000 0000 1111 1111
        // &运算结果 0000 0000 0000 0000 0000 0000 1111 0000
        // 右移4位(0000) 0000 0000 0000 0000 0000 0000 1111 (0000)
        // 即:0000 0000 0000 0000 0000 0000 0000 1111 为15
        System.out.println("(a & 0xff) >> 4 : " + ((a & 0xff) >> 4));

        // 2.5.3 直接使用int值计算
        // 0xf0这里还是要看成int类型
        // 0xf0原码,补码:0000 0000 0000 0000 0000 0000 1111 0000
        // 右移4位 (0000) 0000 0000 0000 0000 0000 0000 1111 即:15
        System.out.println("(0xf0 >> 4)" + (0xf0 >> 4));

        // 2.6 带符号右移与无符号右移的特殊情况
        // 2.6.1 两者计算结果一致
        // 因为先做了&运算,将符号位清空了,所以这个结果同上面一样
        System.out.println("(a & 0xff) >>> 4 : " + ((a & 0xff) >>> 4));

        // 2.6.2 两者计算结果不一致
        // 补码:      1111 0001 0000 0000 0000 0000 0000 0000
        // 右移24位: (1111 1111 1111 1111 1111 1111) 1111 0001
        // 减一:     1111 1111 1111 1111 1111 1111 1111 0000
        // 取反:     1000 0000 0000 0000 0000 0000 0000 1111 即:-15
        System.out.println("0xf1000000 >> 24 :" + (0xf1000000 >> 24));

        // 补码:      1111 0001 0000 0000 0000 0000 0000 0000
        // 右移24位: (0000 0000 0000 0000 0000 0000) 1111 0001 即:241
        System.out.println("0xf1000000 >>> 24 :" + (0xf1000000 >>> 24));

        System.out.println("(0xf1000000 & 0xff000000) >> 24 :" + ((0xf1000000 & 0xff000000) >> 24));
        System.out.println("(0xf1000000 & 0xff000000) >>> 24 :" + ((0xf1000000 & 0xff000000) >>> 24));


        // 结论:java 位移运算中,参与的变量会被转换成int类型,然后再做位运算,
        // 利用&取位操作,有时候可以规避>>带符号的问题.如-16 & 0xff,
        // 但是这个场景比较有限0xf1000000 & 0xff000000这种就不行
        // 所以设计网络传输的大小端操作问题右移应该选择无符号的>>>

        float valuef = 3.14f;
        int valuei = (int) valuef;
    }
}
